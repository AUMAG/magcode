
@ About this file. This is a `literate programming` approach to writing Matlab
code using \textsc{matlabweb}%
\footnote{\url{http://tug.ctan.org/pkg/matlabweb}}. To be honest I don't know
if it's any better than simply using the Matlab programming language directly.
The big advantage for me is that you have access to the entire \LaTeX\
document environment, which gives you access to vastly better tools for
cross-referencing, maths typesetting, structured formatting, bibliography
generation, and so on.

The downside is obviously that you miss out on Matlab's IDE with its
integrated M-Lint program, debugger, profiler, and so on. Depending on ones
work habits, this may be more or less of limiting factor to using `literate
programming' in this way.

@* Calculating forces between magnets. This is the source to some code to
calculate the forces (and perhaps torques) between two cuboid-shaped magnets
with arbitary displacement and magnetisation direction.

If this code works then I'll look at calculating the forces for magnets with
rotation as well.

@( magnetforces.m @>=

[forces torques] = function magnetforces(magnet_fixed, magnet_float, magnet_disp);

@< Matlab help text @>

@< Extract input variables @>
@< Decompose orthogonal superpositions @>
@< Transform coordinate systems and calculate force components @>
@< Recombine results @>

end

@< Functions for calculating forces and stiffnesses @>

@ First of all, address the data structures required for the input and output.
Because displacement of a single magnet has three components, plus sizes of
the faces another three, plus magnetisation strength and direction (two) makes
nine in total, we use one of Matlab's structures to pass the information into
the function. Otherwise we'd have an overwhelming number of input arguments.

We use spherical coordinates to represent magnetisation angle, where |theta|
is the angle from the vertical ($0\le\theta\le\pi$) and |phi| is the angle around
the horizontal plane ($0\le\phi\le2\pi$).

@< Extract ... @>=

  a1 = 0.5*magnet_fixed.dim(1);
  b1 = 0.5*magnet_fixed.dim(2);
  c1 = 0.5*magnet_fixed.dim(3);
  a2 = 0.5*magnet_float.dim(1);
  b2 = 0.5*magnet_float.dim(2);
  c2 = 0.5*magnet_float.dim(3);
  
  J1r = magnet_fixed.magn;
  J2r = magnet_float.magn;
  J1t = magnet_fixed.magdir(1);
  J2t = magnet_float.magdir(1);
  J1p = magnet_fixed.magdir(2);
  J2p = magnet_float.magdir(2);
  
  dx = magnet_disp(1);
  dy = magnet_disp(2);
  dz = magnet_disp(3);

@ Superposition is used to turn an arbitrary magnetisation angle into a set of
orthogonal magnetisations.

Each magnet can potentially have three components, which can result in up
to nine force calculations for a single magnet.

@< Decompose ... @>=

[J1x J1y J1z] = sph2cart(J1t,J1p,J1r);
[J2x J2y J2z] = sph2cart(J2t,J2p,J2r);


@ The expressions we have to calculate the forces assume a fixed magnet with
positive |z| magnetisation only. Secondly, magnetisation direction of the
floating magnet may only be in the positive |z|- or |y|-directions.

The parallel forces are more easily visualised; if |J1z| is negative, then
transform the coordinate system so that up is down and down is up. Then proceed
as usual and reverse the vertical forces in the last step.

The orthogonal forces require reflection and/or rotation to get the displacements
in a form suitable for calculation.

@< Transform ... @>=

@< Precompute rotation matrices @>

force_components_x = zeros(3);
force_components_y = zeros(3);
force_components_z = zeros(3);

@< Calculate parallel forces @>
@< Calculate orthogonal forces @>

@ The parallel forces are easier, so I'll do them first.

@< Calculate parallel forces @>=

if ~( J1x == 0 || J2x == 0 )
  @< Calculate forces |x|-|x| @>
end
if ~( J1y == 0 || J2y == 0 )
  @< Calculate forces |y|-|y| @>
end
if ~( J1z == 0 || J2z == 0 )
  @< Calculate forces |z|-|z| @>
end

@ It becomes much hard to visualise how the coordinates should be transformed
for the orthogonal magnetisations.

@< Calculate orthogonal forces @>=




@ The easy one. Note that |J1z| and |J2z| can be negative and the forces
  calculated will be correct.

@< Calculate forces |z|-|z| @>=

[Fx Fy Fz] = forces_parallel(a1,b1,c1,a2,b2,c2,dx,dy,dz,J1z,J2z);
force_components(3,3,:) = [Fx Fy Fz];

@ Rotate the entire coordinate system around the |y|-axis so that
  the new |z| is the old |x|. After the forces are calculated, rotate them
  back to the original coordinate system.

@< Calculate forces |x|-|x| @>=

[dxr dyr dzr] = rotate_x_to_z([dx dy dz]);
[Fx Fy Fz] = forces_parallel(c1,b1,a1,c2,b2,a2,dxr,dyr,dzr,J1x,J2x);
force_components(1,1,:) = rotate_z_to_x([Fx Fy Fz]);

@ Rotate again, this time making |x| the `up' direction.

@< Calculate forces |y|-|y| @>=

[dxr dyr dzr] = rotate_y_to_z([dx dy dz]);
[Fx Fy Fz] = forces_parallel(a1,c1,b1,a2,c2,b2,dxr,dyr,dzr,J1y,J2y);
force_components(2,2,:) = rotate_z_to_y([Fx Fy Fz]);

@ Next

@< Recombine ... @>=

@* Functions for calculating forces and stiffnesses. The calculations for
forces between differently-oriented cuboid magnets are all directly from the
literature. The stiffnesses have been derived by differentiating the force
expressions, but that's the easy part.

@< Functions ... @>=

@< Parallel magnets force calculation @>
@< Parallel magnets stiffness calculation @>
@< Orthogonal magnets force calculation @>
@< Orthogonal magnets stiffness calculation @>

@ The expressions here follow directly from \textcite{akoun1984}.

\begin{center}
\begin{tabular}{lll}
 Inputs:
 &    |(a,b,c)| & the half dimensions of the fixed magnet \\
 &    |(A,B,C)| & the half dimensions of the floating magnet \\
 & |(dx,dy,dz)| & distance between magnet centres \\
 &     |(J,J2)| & magnetisations of the magnet(s) in the z-direction \\
 Outputs:
 & |(Fx,Fy,Fz)| & Forces of the second magnet \\
\end{tabular}
\end{center}

@< Parallel magnets force calculation @>=

function [Fx Fy Fz] = forces_parallel(a,b,c,A,B,C,dx,dy,dz,J,J2)
% You probably want to call
%   warning off MATLAB:divideByZero
%   warning off MATLAB:log:logOfZero

if nargin < 11
  J2=J;
elseif nargin < 10
  error('Wrong number of input arguments.')
end

[index_h, index_j, index_k, index_l, index_p, index_q] = ndgrid([0 1]);
index_sum = (-1).^(index_h+index_j+index_k+index_l+index_p+index_q);

% (Using this method is actually LESS efficient than using six for
% loops for h..q over [0 1], but it looks a bit nicer, huh?)

u = dx + A*(-1).^index_j - a*(-1).^index_h;
v = dy + B*(-1).^index_l - b*(-1).^index_k;
w = dz + C*(-1).^index_q - c*(-1).^index_p;
r = sqrt(u.^2+v.^2+w.^2);

f_x = ...
  + 0.5*(v.^2-w.^2).*log(r-u) ...
  + u.*v.*log(r-v) ...
  + v.*w.*atan(u.*v./r./w) ...
  + 0.5*r.*u;

f_y = ...
  + 0.5*(u.^2-w.^2).*log(r-v) ...
  + u.*v.*log(r-u) ...
  + u.*w.*atan(u.*v./r./w)...
  + 0.5*r.*v;

f_z = ...
  - u.*w.*log(r-u) ...
  - v.*w.*log(r-v) ...
  + u.*v.*atan(u.*v./r./w) ...
  - r.*w;

fx = index_sum.*f_x;
fy = index_sum.*f_y;
fz = index_sum.*f_z;

magconst = J*J2/(4*pi*(4*pi*1e-7));
Fx = magconst*sum(fx(:));
Fy = magconst*sum(fy(:));
Fz = magconst*sum(fz(:));

end

@ And these are the stiffnesses.

\begin{center}
\begin{tabular}{lll}
 Inputs:
 &    |(a,b,c)| & the half dimensions of the fixed magnet \\
 &    |(A,B,C)| & the half dimensions of the floating magnet \\
 & |(dx,dy,dz)| & distance between magnet centres \\
 &     |(J,J2)| & magnetisations of the magnet(s) in the z-direction \\
 Outputs:
 & |(Kx,Ky,Kz)| & Stiffnesses of the 2nd magnet \\
\end{tabular}
\end{center}

@< Parallel magnets stiffness calculation @>=

function [Kx Ky Kz] = stiffness_parallel(a,b,c,A,B,C,dx,dy,dz,J,J2)
% You probably want to call
%   warning off MATLAB:divideByZero
%   warning off MATLAB:log:logOfZero

if nargin < 11
  J2=J;
elseif nargin < 10
  error('Wrong number of input arguments.')
end

[index_h, index_j, index_k, index_l, index_p, index_q] = ndgrid([0 1]);
index_sum = (-1).^(index_h+index_j+index_k+index_l+index_p+index_q);

% Using this method is actually less efficient than using six for
% loops for h..q over [0 1]. To be addressed.

u = dx + A*(-1).^index_j - a*(-1).^index_h;
v = dy + B*(-1).^index_l - b*(-1).^index_k;
w = dz + C*(-1).^index_q - c*(-1).^index_p;
r = sqrt(u.^2+v.^2+w.^2);


k_x = ...
  - r ...
  - (u.^2.*v)./(u.^2+w.^2) ...
  - v.*log(r-v) ;
k_y = ...
  - r ...
  - (v.^2.*u)./(v.^2+w.^2) ...
  - u.*log(r-u) ;

k_z = -k_x-k_y;

kx = index_sum.*k_x;
ky = index_sum.*k_y;
kz = index_sum.*k_z;

magconst = J*J2/(4*pi*(4*pi*1e-7));
Kx = magconst*sum(kx(:));
Ky = magconst*sum(ky(:));
Kz = magconst*sum(kz(:));

end

@ Orthogonal magnets forces given by \textcite{yonnet2009-ldia}.
The magnetisation of the floating magnet |J2| is in the positive |y|-direction.

@< Orthogonal magnets force calculation @>=

function [Fx Fy Fz] = forces_orthogonal(a,b,c,A,B,C,dx,dy,dz,J,J2)

if nargin < 11
  J2=J;
elseif nargin < 10
  error('Wrong number of input arguments.')
end

[index_h, index_j, index_k, index_l, index_p, index_q] = ndgrid([0 1]);
index_sum = (-1).^(index_h+index_j+index_k+index_l+index_p+index_q);

% (Using this method is actually LESS efficient than using six for
% loops for h..q over [0 1], but it looks a bit nicer, huh?)

u = dx + A*(-1).^index_j - a*(-1).^index_h;
v = dy + B*(-1).^index_l - b*(-1).^index_k;
w = dz + C*(-1).^index_q - c*(-1).^index_p;
r = sqrt(u.^2+v.^2+w.^2);

f_x = ...
  - v .* w .* ln( r-u ) ...
  + v .* u .* ln( r+w ) ...
  + w .* u .* ln( r+v ) ...
  - 0.5 * u.^2 .* arctan( v .* w ./ ( u .* r) ) ...
  - 0.5 * v.^2 .* arctan( u .* w ./ ( v .* r) ) ...
  - 0.5 * w.^2 .* arctan( u .* v ./ ( w .* r) );

fy = ...
  0.5 * ( u.^2 - v.^2 ) .* ln( r+w ) ...
  - u .* w .* ln ( r-u ) ...
  - u .* v .* arctan( u .* w ./ ( v .* r) ) ...
  - 0.5 * w .* r;

fz = ...
  0.5 * ( u.^2 - w.^2 ) .* ln( r+v ) ...
  - u .* v .* ln ( r-u ) ...
  - u .* w .* arctan( u .* v ./ ( w .* r) ) ...
  - 0.5 * v .* r;

fx = index_sum.*f_x;
fy = index_sum.*f_y;
fz = index_sum.*f_z;

magconst = J*J2/(4*pi*(4*pi*1e-7));
Fx = magconst*sum(fx(:));
Fy = magconst*sum(fy(:));
Fz = magconst*sum(fz(:));

@ Orthogonal magnets stiffnesses.

@< Orthogonal magnets stiffness calculation @>=

@% not yet calculated


@ When the forces are rotated we use these rotation matrices to avoid
  having to think too hard.

@< Precompute rotation matrices @>=

Rx = @@(theta) [1 0 0; 0 cos(theta) -sin(theta); 0 sin(theta) cos(theta)] ;
Ry = @@(theta) [cos(theta) 0 sin(theta); 0 1 0; -sin(theta) 0 cos(theta)] ;
Rz = @@(theta) [cos(theta) -sin(theta) 0; sin(theta) cos(theta) 0; 0 0 1] ;

rotate_z_to_x = @@(vec) Ry(pi/2)*vec'
rotate_x_to_z = @@(vec) Ry(-pi/2)*vec'

rotate_z_to_y = @@(vec) Rx(-pi/2)*vec'
rotate_y_to_z = @@(vec) Rx(pi/2)*vec'


@ When users type \texttt{help magnetforces} this is what they see. This is
  designed to be displayed in a fixed-width font so the output here will be
  fairly ugly.

@< Matlab help text @>=

@%% MAGNETFORCES  Calculate forces between two cuboid magnets
@%
@% Finish this off later.   
@%





@* Test files. The chunks that follow are designed to be saved into
   individual files and executed automatically to check for (a) correctness
   and (b) regression problems as the code evolves.
   
   How do I know if the code produces the correct forces?
   Well, for many cases I can compare with published values in the literature.
   Beyond that, I'll be setting up some tests that I can logically infer
   should produce the same results (such as mirror-image displacements)
   and test that.
   
   There are many Matlab unit test frameworks but I'll be using a fairly
   low-tech method. In time this test suite should be (somehow) useable for
   all implementations of \texttt{magnetocode}, not just Matlab.

@( magforce-test001a.m @>=

magnet_fixed.dim = [0.02 0.04 0.06];
magnet_fixed.magn = 1.3;
magnet_fixed.madir = [0 0]; % vertical

magnet_float.dim = [0.07 0.05 0.03];
magnet_float.magn = 1.1;
magnet_float.madir = [0 0]; % vertical

magnet_disp = [0.1 0.15 0.05];
