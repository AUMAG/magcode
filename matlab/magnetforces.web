
@ About this file. This is a `literate programming` approach to writing Matlab
code using \textsc{matlabweb}%
\footnote{\url{http://tug.ctan.org/pkg/matlabweb}}. To be honest I don't know
if it's any better than simply using the Matlab programming language directly.
The big advantage for me is that you have access to the entire \LaTeX\
document environment, which gives you access to vastly better tools for
cross-referencing, maths typesetting, structured formatting, bibliography
generation, and so on.

The downside is obviously that you miss out on Matlab's IDE with its
integrated M-Lint program, debugger, profiler, and so on. Depending on ones
work habits, this may be more or less of limiting factor to using `literate
programming' in this way.

@* Calculating forces between magnets. This is the source to some code to
calculate the forces (and perhaps torques) between two cuboid-shaped magnets
with arbitary displacement and magnetisation direction.

If this code works then I'll look at calculating the forces for magnets with
rotation as well.

@ The main function is called |magnetforces|, which takes three arguments:
  |magnet_fixed|, |magnet_float|, and |displ|. These will be described below.

@( magnetforces.m @>=

function [forces_out] = magnetforces(magnet_fixed, magnet_float, displ)

@< Matlab help text @>

@< Extract input variables @>
@< Decompose orthogonal superpositions @>
@< Calculate all forces @>

end

@< Functions for calculating forces and stiffnesses @>

@ First of all, address the data structures required for the input and output.
Because displacement of a single magnet has three components, plus sizes of
the faces another three, plus magnetisation strength and direction (two) makes
nine in total, we use one of Matlab's structures to pass the information into
the function. Otherwise we'd have an overwhelming number of input arguments.

We use spherical coordinates to represent magnetisation angle, where |phi| is
the angle from the horizontal plane ($-\pi/2\le \phi \le\pi/2$) and |theta|
is the angle around the horizontal plane ($0\le\theta\le2\pi$). This follows
Matlab's definition; other conventions are commonly used as well. Remember:
\begin{quote}
$(1,0,0)_{\text{cartesian}} \equiv (0,0,1)_{\text{spherical}}$\\
$(0,1,0)_{\text{cartesian}} \equiv (\pi/2,0,1)_{\text{spherical}}$\\
$(0,0,1)_{\text{cartesian}} \equiv (0,\pi/2,1)_{\text{spherical}}$
\end{quote}

@< Extract ... @>=

a1 = 0.5*magnet_fixed.dim(1);
b1 = 0.5*magnet_fixed.dim(2);
c1 = 0.5*magnet_fixed.dim(3);
size1 = [a1; b1; c1];
a2 = 0.5*magnet_float.dim(1);
b2 = 0.5*magnet_float.dim(2);
c2 = 0.5*magnet_float.dim(3);
size2 = [a2; b2; c2];

J1r = magnet_fixed.magn;
J2r = magnet_float.magn;
J1t = magnet_fixed.magdir(1);
J2t = magnet_float.magdir(1);
J1p = magnet_fixed.magdir(2);
J2p = magnet_float.magdir(2);

if (J1r<0 || J2r<0)
  error('By convention, magnetisation must be positive; change the angle to reverse direction.')
end

@ Superposition is used to turn an arbitrary magnetisation angle into a set of
orthogonal magnetisations.

Each magnet can potentially have three components, which can result in up
to nine force calculations for a single magnet.

We don't use Matlab's |sph2cart| here, because it doesn't calculate zero
accurately (because it uses radians and |cos(pi/2)| can only be evaluated
to machine precision rather than symbolically).

@< Decompose ... @>=

displ = reshape(displ,[3 1]); % column vector

J1 = [ J1r * cosd(J1p) * cosd(J1t)  ; ...
       J1r * cosd(J1p) * sind(J1t)  ; ...
       J1r * sind(J1p) ];

J2 = [ J2r * cosd(J2p) * cosd(J2t)  ; ...
       J2r * cosd(J2p) * sind(J2t)  ; ...
       J2r * sind(J2p) ];

@ The expressions we have to calculate the forces assume a fixed magnet with
positive |z| magnetisation only. Secondly, magnetisation direction of the
floating magnet may only be in the positive |z|- or |y|-directions.

The parallel forces are more easily visualised; if |J1z| is negative, then
transform the coordinate system so that up is down and down is up. Then proceed
as usual and reverse the vertical forces in the last step.

The orthogonal forces require reflection and/or rotation to get the displacements
in a form suitable for calculation.

Initialise a $3\times3\times3$ array to store each force component in each
direction, and fill it up by calculating

@< Calculate all forces @>=

force_components = repmat(NaN,[9 3]);

@< Precompute rotation matrices @>

@< Calculate forces |x| @>
@< Calculate forces |y| @>
@< Calculate forces |z| @>

@< Print diagnostics @>

forces_out = sum(force_components);

@ Let's print information to the terminal to aid debugging.
  This is especially important (for me) when looking at the rotated
  coordinate systems.

@< Print ... @>=

disp('  ')
disp('CALCULATING FORCES')
disp('==================')
disp('Displacement:')
disp(displ)
disp('Magnetisations:')
disp(J1)
disp(J2)

@ The easy one first, where our magnetisation components align with the
  direction expected by the force functions.

@< Calculate forces |z| @>=

if J1(3) < 0
  coord_transform = reverse_z
else
  coord_transform = reverse_none
end

   d_trans = coord_transform(displ);
  J1_trans = coord_transform(J1);
  J2_trans = coord_transform(J2);

forces_z_z = forces_z_z( size1,size2,d_trans,J1_trans,J2_trans );
force_components(7,:) = coord_transform(forces_z_z);

forces_z_y = forces_z_y( size1,size2,d_trans,J1_trans,J2_trans );
force_components(8,:) = coord_transform(forces_z_y);

forces_z_x = forces_z_x( size1,size2,d_trans,J1_trans,J2_trans );
force_components(9,:) = coord_transform(forces_z_x);

@ Print these forces.

@< Print ... @>+=

disp('Forces z-x:')
disp(forces_z_x)
disp('Forces z-y:')
disp(forces_z_y)
disp('Forces z-z:')
disp(forces_z_z)

@ The other forces (i.e., |x| and |y| components) require a rotation to get
  the magnetisations correctly aligned.
  In the case of the magnet sizes, the lengths are just flipped rather than
  rotated (in rotation, sign is important).
  After the forces are calculated, rotate them back to the original
  coordinate system.

@< Calculate forces |x| @>=

size1_rot = flip_x_z(size1);
size2_rot = flip_x_z(size2);
d_rot  = rotate_x_to_z(displ);
J1_rot = rotate_x_to_z(J1);
J2_rot = rotate_x_to_z(J2);

if J2_rot(2) < 0
  coord_transform = reverse_y
else
  coord_transform = reverse_none
end

   d_trans = coord_transform( d_rot);
  J1_trans = coord_transform(J1_rot);
  J2_trans = coord_transform(J2_rot);

forces_x_x = forces_z_z(size1_rot,size2_rot,d_trans,J1_trans,J2_trans);
force_components(1,:) = rotate_z_to_x( coord_transform(forces_x_x) );

forces_x_y = forces_z_y(size1_rot,size2_rot,d_trans,J1_trans,J2_trans);
force_components(2,:) = rotate_z_to_x( coord_transform(forces_x_y) );

forces_x_z = forces_z_y(size1_rot,size2_rot,d_trans,J1_trans,J2_trans);
force_components(3,:) = rotate_z_to_x( coord_transform(forces_x_z) );

@ Print these forces.
@< Print ... @>+=

disp('Forces x-x:')
disp(forces_x_x)
disp('Forces x-y:')
disp(forces_x_y)
disp('Forces x-z:')
disp(forces_x_z)

@ Same again, this time making |y| the `up' direction.

@< Calculate forces |y| @>=

size1_rot = flip_y_z(size1);
size2_rot = flip_y_z(size2);
d_rot     = rotate_y_to_z( displ );
J1_rot    = rotate_y_to_z( J1    );
J2_rot    = rotate_y_to_z( J2    );

if J2_rot(2) < 0
  coord_transform = reverse_y ;
else
  coord_transform = reverse_none ;
end

   d_trans = coord_transform( d_rot);
  J1_trans = coord_transform(J1_rot);
  J2_trans = coord_transform(J2_rot);

forces_y_x = forces_z_x(size1_rot,size2_rot,d_trans,J1_trans,J2_trans);
force_components(4,:) = rotate_z_to_y( coord_transform(forces_y_x) );

forces_y_y = forces_z_z(size1_rot,size2_rot,d_trans,J1_trans,J2_trans);
force_components(5,:) = rotate_z_to_y( coord_transform(forces_y_y) );

forces_y_z = forces_z_y(size1_rot,size2_rot,d_trans,J1_trans,J2_trans);
force_components(6,:) = rotate_z_to_y( coord_transform(forces_y_z) );


@ Print these forces.

@< Print ... @>+=

disp('Forces y-x:')
disp(forces_y_x)
disp('Forces y-y:')
disp(forces_y_y)
disp('Forces y-z:')
disp(forces_y_z)


@* Functions for calculating forces and stiffnesses. The calculations for
forces between differently-oriented cuboid magnets are all directly from the
literature. The stiffnesses have been derived by differentiating the force
expressions, but that's the easy part.

@< Functions ... @>=

@< Parallel magnets force calculation @>
@< Orthogonal magnets force calculation @>

@ The expressions here follow directly from \textcite{akoun1984}.

\begin{center}
\begin{tabular}{lll}
 Inputs:
 & |size1|=|(a,b,c)| & the half dimensions of the fixed magnet \\
 & |size2|=|(A,B,C)| & the half dimensions of the floating magnet \\
 & |displ|=|(dx,dy,dz)| & distance between magnet centres \\
 &     |(J,J2)| & magnetisations of the magnet in the z-direction \\
 Outputs:
 & |forces_xyz|=|(Fx,Fy,Fz)| & Forces of the second magnet \\
\end{tabular}
\end{center}

@< Parallel magnets force calculation @>=

function forces_xyz = forces_z_z(size1,size2,offset,J1,J2)
% You probably want to call
%   warning off MATLAB:divideByZero
%   warning off MATLAB:log:logOfZero

if length(J1) == 3
  J1 = J1(3);
end
if length(J2) == 3
  J2 = J2(3);
end

@< Forces initialise variables @>

f_x = ...
  + 0.5*(v.^2-w.^2).*log(r-u) ...
  + u.*v.*log(r-v) ...
  + v.*w.*atan(u.*v./r./w) ...
  + 0.5*r.*u;

f_y = ...
  + 0.5*(u.^2-w.^2).*log(r-v) ...
  + u.*v.*log(r-u) ...
  + u.*w.*atan(u.*v./r./w)...
  + 0.5*r.*v;

f_z = ...
  - u.*w.*log(r-u) ...
  - v.*w.*log(r-v) ...
  + u.*v.*atan(u.*v./r./w) ...
  - r.*w;

fx = index_sum.*f_x;
fy = index_sum.*f_y;
fz = index_sum.*f_z;

magconst = J1*J2/(4*pi*(4*pi*1e-7));
forces_xyz = magconst.*[ sum(fx(:)) sum(fy(:)) sum(fz(:)) ] ;

end

@ Orthogonal magnets forces given by \textcite{yonnet2009-ldia}.
The magnetisation of the floating magnet |J2| is in the positive |y|-direction.

@< Orthogonal magnets force calculation @>=

function forces_xyz = forces_z_x(size1,size2,offset,J1,J2)

swap_x_y = @@(vec) [vec(2); vec(1); vec(3)];

forces_xyz = forces_z_y(...
  swap_x_y(size1), swap_x_y(size2), swap_x_y(offset),...
  J1, swap_x_y(J2) );

forces_xyz = swap_x_y( forces_xyz );

end

function forces_xyz = forces_z_y(size1,size2,offset,J1,J2)

if length(J1) == 3
  J1 = J1(3);
end
if length(J2) == 3
  J2 = J2(2);
end

@< Forces initialise variables @>

if (J1<0 || J2<0)
  error('Positive magnetisations only!')
end

f_x = ...
  - v .* w .* log( r-u ) ...
  + v .* u .* log( r+w ) ...
  + u .* w .* log( r+v ) ...
  - 0.5 * u.^2 .* atan( v .* w ./ ( u .* r) ) ...
  - 0.5 * v.^2 .* atan( u .* w ./ ( v .* r) ) ...
  - 0.5 * w.^2 .* atan( u .* v ./ ( w .* r) );

f_y = ...
  0.5 * ( u.^2 - v.^2 ) .* log( r+w ) ...
  - u .* w .* log ( r-u ) ...
  - u .* v .* atan( u .* w ./ ( v .* r) ) ...
  - 0.5 * w .* r;

f_z = ...
  0.5 * ( u.^2 - w.^2 ) .* log( r+v ) ...
  - u .* v .* log ( r-u ) ...
  - u .* w .* atan( u .* v ./ ( w .* r) ) ...
  - 0.5 * v .* r;

fx = index_sum.*f_x;
fy = index_sum.*f_y;
fz = index_sum.*f_z;

magconst = J1*J2/(4*pi*(4*pi*1e-7));
forces_xyz = magconst.*[ sum(fx(:)) sum(fy(:)) sum(fz(:)) ] ;


end

@ Some shared setup code. First |return| early if either of the magnetisations
  are zero --- that's the trivial solution. Assume that the magnetisation
  has already been `chopped'; i.e., that we don't need to check for |J1| or
  |J2| less than |1e-12| or whatever.

  (I'm using the Mathematica definition of |chop| here; in Matlab it means
  truncate to a certain number of significant figures.)

@< Forces initialise variables @>=

if (J1==0 || J2==0)
  forces_xyz = [0; 0; 0];
  return;
end

dx = offset(1);
dy = offset(2);
dz = offset(3);

a = size1(1);
b = size1(2);
c = size1(3);
A = size2(1);
B = size2(2);
C = size2(3);

[index_h, index_j, index_k, index_l, index_p, index_q] = ndgrid([0 1]);
index_sum = (-1).^(index_h+index_j+index_k+index_l+index_p+index_q);

% (Using this vectorised method is actually less efficient than using six |for|
% loops over |[0, 1]|. To be addressed.)

u = dx + A*(-1).^index_j - a*(-1).^index_h;
v = dy + B*(-1).^index_l - b*(-1).^index_k;
w = dz + C*(-1).^index_q - c*(-1).^index_p;
r = sqrt(u.^2+v.^2+w.^2);




@ When the forces are rotated we use these rotation matrices to avoid
  having to think too hard.
  Use degrees in order to compute $sin \pi/2$ exactly!

@< Precompute rotation matrices @>=

Rx = @@(theta) [1 0 0; 0 cosd(theta) -sind(theta); 0 sind(theta) cosd(theta)] ;
Ry = @@(theta) [cosd(theta) 0 sind(theta); 0 1 0; -sind(theta) 0 cosd(theta)] ;
Rz = @@(theta) [cosd(theta) -sind(theta) 0; sind(theta) cosd(theta) 0; 0 0 1] ;

rotate_z_to_x = @@(vec)  Ry( 90)*vec ;
rotate_x_to_z = @@(vec)  Ry(-90)*vec ;
flip_x_z = @@(vec) abs(rotate_x_to_z(vec)) ;
                                        
rotate_z_to_y = @@(vec)  Rx(-90)*vec ;
rotate_y_to_z = @@(vec)  Rx( 90)*vec ;
flip_y_z = @@(vec) abs(rotate_y_to_z(vec)) ;

reverse_z = @@(vec) Ry(180)*vec ;
reverse_y = @@(vec) Rz(180)*vec ;

reverse_none = @@(vec) vec ;

@ When users type \texttt{help magnetforces} this is what they see. This is
  designed to be displayed in a fixed-width font so the output here will be
  fairly ugly.

@< Matlab help text @>=

@%% MAGNETFORCES  Calculate forces between two cuboid magnets
@%
@% Finish this off later.   
@%





@* Test files. The chunks that follow are designed to be saved into
   individual files and executed automatically to check for (a) correctness
   and (b) regression problems as the code evolves.

   How do I know if the code produces the correct forces?
   Well, for many cases I can compare with published values in the literature.
   Beyond that, I'll be setting up some tests that I can logically infer
   should produce the same results (such as mirror-image displacements)
   and test that.

   There are many Matlab unit test frameworks but I'll be using a fairly
   low-tech method. In time this test suite should be (somehow) useable for
   all implementations of \texttt{magnetocode}, not just Matlab.


@  This test checks that square magnets produce the same forces in the
   each direction when displaced in positive and negative
   |x|, |y|, and |z| directions, respectively.
   In other words, this tests the function |forces_z_y| directly.
   Both positive and negative magnetisations are used.

@( magforce_test001a.m @>=

magnet_fixed.dim = [0.04 0.04 0.04];
magnet_float.dim = magnet_fixed.dim;

magnet_fixed.magn = 1.3;
magnet_float.magn = 1.3;
offset = 0.1;

@< Test $z$--$z$ magnetisations @>
@< Assert parallel magnetisations tests @>

@< Test $x$--$x$ magnetisations @>
@< Assert parallel magnetisations tests @>

@< Test $y$--$y$ magnetisations @>
@< Assert parallel magnetisations tests @>




disp('============')
disp('Tests passed')
disp('============')


@ Testing vertical forces.

@< Test $z$--$z$ magnetisations @>=
f = [];

for ii = [1, -1]
  magnet_fixed.magdir = [0 ii*90]; % $\pm z$
  for jj = [1, -1]
    magnet_float.magdir = [0 jj*90];
    for kk = [1, -1]
      displ = kk*[0 0 offset]+eps;
      f(:,end+1) = magnetforces(magnet_fixed,magnet_float,displ);
    end
  end
end

dirforces = chop( f(3,:), 8 );
otherforces = f([1 2],:);

@ Testing horizontal $x$ forces.

@< Test $x$--$x$ magnetisations @>=

f = [];

for ii = [1, -1]
  magnet_fixed.magdir = [90+ii*90 0]; % $\pm x$
  for jj = [1, -1]
    magnet_float.magdir = [90+jj*90 0];
    for kk = [1, -1]
      displ = kk*[offset 0 0]+eps;
      f(:,end+1) = magnetforces(magnet_fixed,magnet_float,displ);
    end
  end
end

dirforces = chop( f(1,:), 8 );
otherforces = f([2 3],:);

@ Testing horizontal $y$ forces.

@< Test $y$--$y$ magnetisations @>=

f = [];

for ii = [1, -1]
  magnet_fixed.magdir = [ii*90 0]; % $\pm y$
  for jj = [1, -1]
    magnet_float.magdir = [jj*90 0];
    for kk = [1, -1]
      displ = kk*[0 offset 0]+eps;
      f(:,end+1) = magnetforces(magnet_fixed,magnet_float,displ);
    end
  end
end

dirforces = chop( f(2,:), 8 );
otherforces = f([1 3],:);


@ The checks, common between directions. Use the subjunctive case to both
  describe the assertions and to output the failed tests.

@< Assert parallel magnetisations tests @>=

assert ( ...
	     all(all( abs( otherforces ) < 1e-11 )) , ...
	     'Horizontal forces should be zero' ...
	   )
assert ( ...
	     all( abs(dirforces) == abs(dirforces(1)) ) , ...
	     'Force magnitudes should be equal' ...
	   )
assert ( ...
	     all( dirforces(1:4) == -dirforces(5:8) ) , ...
	     'Forces should be opposite with reversed fixed magnet magnetisation' ...
	   )
assert ( ...
	     all( dirforces([1 3 5 7]) == -dirforces([2 4 6 8]) ) , ...
	     'Forces should be opposite with reversed float magnet magnetisation' ...
	   )


@ This test does the same thing but for orthogonally magnetised magnets.

@( magforce_test001b.m @>=


f = [];

magnet_fixed.dim = [0.04 0.04 0.04];
magnet_float.dim =  magnet_fixed.dim;

magnet_fixed.magn = 1.3;
magnet_float.magn = 1.3;

magnet_fixed.magdir = [0  90];  % $z$
for ii = [1, -1]
  for jj = [1, -1]

    magnet_float.magdir = ii*[90 0];  % $\pm y$
    displ = jj*[0 0 0.1];  % $\pm z$
    f(:,end+1) = magnetforces(magnet_fixed,magnet_float,displ+eps);

    pause

  end
end


% chop:
f( abs(f)<1e-10 ) = 0;
